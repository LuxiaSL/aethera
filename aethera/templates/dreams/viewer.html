{% extends "base.html" %}

{% block title %}Dreams | æthera{% endblock %}

{% block description %}Live AI-generated morphing art. Watch ethereal digital dreams evolve in real-time.{% endblock %}

{% block meta %}
{{ super() }}
<!-- Dreams-specific Open Graph -->
<meta property="og:title" content="Dreams | æthera">
<meta property="og:description" content="Live AI-generated morphing art. Watch ethereal digital dreams evolve in real-time.">
<meta property="og:image" content="{{ request.base_url }}api/dreams/current">
<meta property="og:type" content="website">
<link rel="canonical" href="{{ request.base_url }}dreams">

<!-- Twitter/X Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Dreams | æthera">
<meta name="twitter:description" content="Live AI-generated morphing art">
<meta name="twitter:image" content="{{ request.base_url }}api/dreams/current">
{% endblock %}

{% block schema %}
<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "Dreams",
    "description": "Live AI-generated morphing art viewer. Continuously evolving ethereal digital imagery powered by stable diffusion.",
    "url": "{{ request.base_url }}dreams",
    "applicationCategory": "MultimediaApplication",
    "operatingSystem": "Web Browser",
    "author": {
        "@type": "Person",
        "name": "Luxia",
        "url": "{{ request.base_url }}"
    }
}
</script>
{% endblock %}

{% block extra_head %}
<link href="/static/css/dreams.css" rel="stylesheet">
{% endblock %}

{% block content %}
<video id="dreams-video-src" autoplay muted loop playsinline style="position:absolute;opacity:0;pointer-events:none;width:1px;height:1px">
    <source src="/static/uploads/dreams_bg.mp4?v=2" type="video/mp4">
</video>
<canvas id="dreams-video-canvas" class="dreams-video-bg"></canvas>
<div class="dreams-page">
    <!-- Page header -->
    <header class="dreams-header">
        <h1 class="dreams-title">dreams</h1>
    </header>

    <!-- Main viewer container -->
    <div class="dream-container">
        <!-- Canvas for frame display -->
        <canvas id="dream-canvas" width="1024" height="512"></canvas>
        
        <!-- Loading overlay -->
        <div id="dream-loading" class="dream-loading">
            <div class="dream-loading-content">
                <div class="dream-pulse-container">
                    <div class="dream-pulse"></div>
                    <div class="dream-pulse dream-pulse-delayed"></div>
                </div>
                <span id="dream-status" class="dream-status">connecting...</span>
                <div class="dream-progress">
                    <div id="dream-progress-bar" class="dream-progress-bar"></div>
                </div>
            </div>
        </div>
        
        <!-- Error overlay -->
        <div id="dream-error" class="dream-error hidden">
            <div class="dream-error-content">
                <span class="dream-error-icon">⚠</span>
                <span id="dream-error-message" class="dream-error-message">connection lost</span>
                <button id="dream-retry-btn" class="dream-retry-btn">retry</button>
            </div>
        </div>
    </div>

    <!-- Status bar -->
    <div class="dream-status-bar">
        <canvas id="status-bar-canvas"></canvas>
        <span id="dream-frame-count" class="dream-stat">
            <span class="dream-stat-label">frame</span>
            <span class="dream-stat-value">—</span>
        </span>
        <span id="dream-viewer-count" class="dream-stat">
            <span class="dream-stat-label">viewers</span>
            <span class="dream-stat-value">—</span>
        </span>
        <span id="dream-connection-status" class="dream-stat">
            <span class="dream-stat-indicator"></span>
            <span class="dream-stat-value">offline</span>
        </span>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="/static/js/dreams.js"></script>
<script>
// Frame-blended background video for smooth slow-motion
(function() {
    const video = document.getElementById('dreams-video-src');
    const canvas = document.getElementById('dreams-video-canvas');
    if (!video || !canvas) return;

    const ctx = canvas.getContext('2d');
    const blendRate = 0.08; // How fast to blend toward current frame

    video.playbackRate = 0.25;
    video.play().catch(() => {});

    // Accumulator canvas - holds the blended result
    let accum = null;
    let accumCtx = null;

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    function initAccum() {
        accum = document.createElement('canvas');
        accum.width = video.videoWidth || 1920;
        accum.height = video.videoHeight || 1080;
        accumCtx = accum.getContext('2d');
        // Initialize with first frame
        accumCtx.drawImage(video, 0, 0, accum.width, accum.height);
    }

    function render() {
        if (video.readyState >= 2) {
            if (!accum) initAccum();

            // Blend current video frame into accumulator
            accumCtx.globalAlpha = blendRate;
            accumCtx.drawImage(video, 0, 0, accum.width, accum.height);
            accumCtx.globalAlpha = 1.0;

            // Draw accumulator to display canvas
            ctx.drawImage(accum, 0, 0, canvas.width, canvas.height);
        }
        requestAnimationFrame(render);
    }

    video.addEventListener('loadeddata', render);
    if (video.readyState >= 2) render();
})();

// Status bar soft fade background (black)
(function() {
    const canvas = document.getElementById('status-bar-canvas');
    if (!canvas) return;

    const gl = canvas.getContext('webgl', { antialias: true });
    if (!gl) return;

    const vertexShaderSource = `
        attribute vec2 a_position;
        varying vec2 v_uv;
        void main() {
            v_uv = a_position * 0.5 + 0.5;
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    `;

    const fragmentShaderSource = `
        precision highp float;
        varying vec2 v_uv;
        void main() {
            vec2 uv = v_uv;
            float horizFade = smoothstep(0.0, 0.1, uv.x) * smoothstep(1.0, 0.9, uv.x);
            float vertFade = smoothstep(0.0, 0.15, uv.y) * smoothstep(1.0, 0.85, uv.y);
            float alpha = horizFade * vertFade;
            gl_FragColor = vec4(0.0, 0.0, 0.0, alpha);
        }
    `;

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function createProgram(gl, vs, fs) {
        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            gl.deleteProgram(program);
            return null;
        }
        return program;
    }

    const vs = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fs = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    if (!vs || !fs) return;

    const program = createProgram(gl, vs, fs);
    if (!program) return;

    const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, 'a_position');

    function resize() {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        gl.viewport(0, 0, canvas.width, canvas.height);
    }

    resize();
    window.addEventListener('resize', resize);

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    function render() {
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.useProgram(program);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }

    render();
})();
</script>
{% endblock %}



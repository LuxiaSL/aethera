{% extends "base.html" %}

{% block title %}Dreams | æthera{% endblock %}

{% block description %}Live AI-generated morphing art. Watch ethereal digital dreams evolve in real-time.{% endblock %}

{% block meta %}
{{ super() }}
<!-- Dreams-specific Open Graph -->
<meta property="og:title" content="Dreams | æthera">
<meta property="og:description" content="Live AI-generated morphing art. Watch ethereal digital dreams evolve in real-time.">
<meta property="og:image" content="{{ request.base_url }}api/dreams/current">
<meta property="og:type" content="website">
<link rel="canonical" href="{{ request.base_url }}dreams">

<!-- Twitter/X Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Dreams | æthera">
<meta name="twitter:description" content="Live AI-generated morphing art">
<meta name="twitter:image" content="{{ request.base_url }}api/dreams/current">
{% endblock %}

{% block schema %}
<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "Dreams",
    "description": "Live AI-generated morphing art viewer. Continuously evolving ethereal digital imagery powered by stable diffusion.",
    "url": "{{ request.base_url }}dreams",
    "applicationCategory": "MultimediaApplication",
    "operatingSystem": "Web Browser",
    "author": {
        "@type": "Person",
        "name": "Luxia",
        "url": "{{ request.base_url }}"
    }
}
</script>
{% endblock %}

{% block extra_head %}
<link href="/static/css/dreams.css" rel="stylesheet">
{% endblock %}

{% block content %}
<div class="dreams-page">
    <!-- Page header -->
    <header class="dreams-header">
        <h1 class="dreams-title">dreams</h1>
    </header>

    <!-- Main viewer container -->
    <div class="dream-container">
        <!-- Soft fade background -->
        <canvas id="dream-bg-canvas" class="dream-bg-canvas"></canvas>
        <!-- Canvas for frame display -->
        <canvas id="dream-canvas" width="1024" height="512"></canvas>
        
        <!-- Loading overlay -->
        <div id="dream-loading" class="dream-loading">
            <div class="dream-loading-content">
                <div class="dream-pulse-container">
                    <div class="dream-pulse"></div>
                    <div class="dream-pulse dream-pulse-delayed"></div>
                </div>
                <span id="dream-status" class="dream-status">connecting...</span>
                <div class="dream-progress">
                    <div id="dream-progress-bar" class="dream-progress-bar"></div>
                </div>
            </div>
        </div>
        
        <!-- Error overlay -->
        <div id="dream-error" class="dream-error hidden">
            <div class="dream-error-content">
                <span class="dream-error-icon">⚠</span>
                <span id="dream-error-message" class="dream-error-message">connection lost</span>
                <button id="dream-retry-btn" class="dream-retry-btn">retry</button>
            </div>
        </div>
    </div>
    
    <!-- Status bar -->
    <div class="dream-status-bar">
        <span id="dream-frame-count" class="dream-stat">
            <span class="dream-stat-label">frame</span>
            <span class="dream-stat-value">—</span>
        </span>
        <span id="dream-viewer-count" class="dream-stat">
            <span class="dream-stat-label">viewers</span>
            <span class="dream-stat-value">—</span>
        </span>
        <span id="dream-connection-status" class="dream-stat">
            <span class="dream-stat-indicator"></span>
            <span class="dream-stat-value">offline</span>
        </span>
    </div>
    
    <!-- Embed & Docs section -->
    <details class="dreams-embed-section">
        <summary>embed this</summary>
        <div class="dreams-embed-content">
            <p>Add Dream Window to your own site:</p>
            <pre class="dreams-embed-code"><code>&lt;iframe 
  src="{{ request.base_url }}dreams?embed=1" 
  width="1024" 
  height="512" 
  frameborder="0"
  loading="lazy"&gt;&lt;/iframe&gt;</code></pre>
            <p class="dreams-embed-note">
                Or fetch the current frame directly: 
                <a href="/api/dreams/current"><code>/api/dreams/current</code></a>
            </p>
        </div>
    </details>
    
    <details class="dreams-embed-section">
        <summary>api documentation</summary>
        <div class="dreams-embed-content">
            <p>Build your own Dream Window client with our API:</p>
            <ul class="dreams-api-links">
                <li><strong>WebSocket:</strong> <code>/ws/dreams</code> — Real-time binary frame stream</li>
                <li><strong>SSE:</strong> <code>/api/dreams/sse</code> — Server-Sent Events alternative</li>
                <li><strong>REST:</strong> <code>/api/dreams/current</code> — Current frame (WebP)</li>
                <li><strong>Status:</strong> <code>/api/dreams/status</code> — System status (JSON)</li>
            </ul>
            <p class="dreams-embed-note">
                <a href="/dreams/api" class="dreams-docs-link">View full API documentation →</a>
            </p>
        </div>
    </details>
</div>
{% endblock %}

{% block scripts %}
<script src="/static/js/dreams.js"></script>
<script>
// Soft fade background for dream container
(function() {
    const canvas = document.getElementById('dream-bg-canvas');
    if (!canvas) return;

    const gl = canvas.getContext('webgl', { antialias: true });
    if (!gl) return;

    const vertexShaderSource = `
        attribute vec2 a_position;
        varying vec2 v_uv;
        void main() {
            v_uv = a_position * 0.5 + 0.5;
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    `;

    const fragmentShaderSource = `
        precision highp float;
        varying vec2 v_uv;
        uniform vec2 u_resolution;

        void main() {
            vec2 uv = v_uv;
            float fadePixels = 40.0;
            float horizFade = smoothstep(0.0, fadePixels / u_resolution.x, uv.x) * smoothstep(1.0, 1.0 - fadePixels / u_resolution.x, uv.x);
            float vertFade = smoothstep(0.0, fadePixels / u_resolution.y, uv.y) * smoothstep(1.0, 1.0 - fadePixels / u_resolution.y, uv.y);
            float alpha = horizFade * vertFade;
            gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
        }
    `;

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function createProgram(gl, vs, fs) {
        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            gl.deleteProgram(program);
            return null;
        }
        return program;
    }

    const vs = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fs = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    if (!vs || !fs) return;

    const program = createProgram(gl, vs, fs);
    if (!program) return;

    const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, 'a_position');
    const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');

    function resize() {
        const container = canvas.parentElement;
        const rect = container.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = (rect.width + 80) * dpr;
        canvas.height = (rect.height + 80) * dpr;
        gl.viewport(0, 0, canvas.width, canvas.height);
    }

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    function render() {
        resize();
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.useProgram(program);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(render);
    }

    render();
})();
</script>
{% endblock %}


